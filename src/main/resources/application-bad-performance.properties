# ========================================
# BAD PERFORMANCE CONFIGURATION
# FOR EDUCATIONAL PURPOSES ONLY
# ========================================
# This profile demonstrates common Hibernate/JPA misconfigurations
# that lead to severe performance issues. Use for comparison demos.
#
# Run with: --spring.profiles.active=bad-performance

# Database Connection
spring.datasource.url=jdbc:postgresql://postgresql:5432/hibernate_formation
spring.datasource.driver-class-name=org.postgresql.Driver
spring.datasource.username=hibernate_user
spring.datasource.password=hibernate_password

# ========================================
# CONNECTION POOL - VERY BAD CONFIGURATION
# ========================================

# ❌ BAD: Only 1 idle connection
# PROBLEM: Every request waits for connection creation
# IMPACT: High latency, threads blocked waiting for connections
# RESULT: Poor concurrency, request timeouts under load
spring.datasource.hikari.minimum-idle=1

# ❌ BAD: Maximum 2 connections
# PROBLEM: Severe bottleneck - only 2 concurrent DB operations
# IMPACT: With 100 users, 98 wait in queue at any moment
# RESULT: Massive slowdown under any real load
spring.datasource.hikari.maximum-pool-size=2

# Connection timeouts (these are OK)
spring.datasource.hikari.connection-timeout=30000
spring.datasource.hikari.idle-timeout=600000
spring.datasource.hikari.max-lifetime=1800000

# ========================================
# JPA/HIBERNATE - BAD CONFIGURATION
# ========================================

# ❌ BAD: SQL logging enabled in production
# PROBLEM: Logs every SQL statement to console/file
# IMPACT: Massive I/O overhead, log files grow exponentially
# RESULT: Up to 30% performance loss just from logging
spring.jpa.show-sql=true

spring.jpa.hibernate.ddl-auto=validate
spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# ❌ BAD: SQL formatting enabled
# PROBLEM: CPU cycles wasted formatting SQL for readability
# IMPACT: Unnecessary string processing on every query
# RESULT: Wasted CPU, slower query execution
spring.jpa.properties.hibernate.format_sql=true

# ❌ BAD: SQL comments enabled
# PROBLEM: Adds metadata comments to every SQL query
# IMPACT: Larger SQL strings, more network traffic, parsing overhead
# RESULT: Slower query transmission and execution
spring.jpa.properties.hibernate.use_sql_comments=true

# Statistics (OK to keep for monitoring)
spring.jpa.properties.hibernate.generate_statistics=true

# ❌ BAD: Batch size = 1 (NO BATCHING!)
# PROBLEM: Each insert/update is a separate database round-trip
# IMPACT: 1000 inserts = 1000 round-trips instead of 20 (with batch=50)
# RESULT: 50x slower bulk operations, massive network overhead
# EXAMPLE: Inserting 10,000 users takes 10,000 queries instead of 200
spring.jpa.properties.hibernate.jdbc.batch_size=1

# ❌ BAD: Fetch size = 1
# PROBLEM: Fetches one row at a time from database
# IMPACT: For 1000 rows, needs 1000 network round-trips
# RESULT: Catastrophic for large result sets, 100x slower than batch fetching
spring.jpa.properties.hibernate.jdbc.fetch_size=1

# ❌ BAD: Batch fetch size = 1
# PROBLEM: Loads collections one entity at a time (N+1 problem amplified)
# IMPACT: Loading 100 users with departments = 101 queries
# RESULT: Classic N+1 problem, exponential query growth
spring.jpa.properties.hibernate.default_batch_fetch_size=1

# Caching disabled (OK for demo purposes)
spring.jpa.properties.hibernate.cache.use_second_level_cache=false
spring.jpa.properties.hibernate.cache.use_query_cache=false

# ❌ BAD: Insert ordering disabled
# PROBLEM: Inserts executed in random order, preventing batch optimization
# IMPACT: Cannot group similar operations, more locks, more deadlocks
# RESULT: Slower bulk inserts, potential database deadlocks
spring.jpa.properties.hibernate.order_inserts=false

# ❌ BAD: Update ordering disabled
# PROBLEM: Updates executed in random order
# IMPACT: More table locks, higher chance of deadlocks
# RESULT: Slower updates, potential transaction failures
spring.jpa.properties.hibernate.order_updates=false

# ❌ BAD: Very aggressive slow query threshold (10ms)
# PROBLEM: Logs almost every query as "slow"
# IMPACT: Log spam, hard to identify truly slow queries
# RESULT: Log noise obscures real performance issues
spring.jpa.properties.hibernate.session.events.log.LOG_QUERIES_SLOWER_THAN_MS=10

# ========================================
# LOGGING - TOO VERBOSE FOR PRODUCTION
# ========================================

# ❌ BAD: DEBUG level for SQL
# PROBLEM: Logs every query with full details
# IMPACT: Massive log files, I/O bottleneck
# RESULT: 20-30% performance overhead, logs fill disk
logging.level.org.hibernate.SQL=DEBUG

# ❌ BAD: TRACE level for SQL parameters
# PROBLEM: Logs every parameter value for every query
# IMPACT: Extreme logging overhead, security risk (passwords in logs)
# RESULT: Up to 50% performance loss, potential data leaks
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE

# ❌ BAD: DEBUG level for statistics
# PROBLEM: Logs detailed statistics after every operation
# IMPACT: Heavy I/O, CPU overhead calculating stats
logging.level.org.hibernate.stat=DEBUG

logging.level.com.formation.hibernate=DEBUG

# ========================================
# PERFORMANCE IMPACT SUMMARY
# ========================================
# Expected performance with this configuration:
# - Connection pool: 95% slower (2 connections vs 50)
# - No batching: 50x slower bulk operations
# - Excessive logging: 30-50% overhead
# - Poor fetch strategy: 100x slower for large datasets
#
# TOTAL IMPACT: 100-1000x slower than optimized configuration!
#
# Real-world example with 1M users:
# - Good config: 30 seconds
# - This config: 8-12 HOURS (yes, hours!)
# ========================================