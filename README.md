# Projeto de Forma√ß√£o - JPA/Hibernate Performance

Este projeto demonstra as **melhores e piores pr√°ticas** de JPA/Hibernate atrav√©s de implementa√ß√µes comparativas, com medi√ß√£o de performance em tempo real.

## üìö Fundamentos Te√≥ricos

### üß† Conceitos Essenciais para Compreender

Antes de mergulhar nas implementa√ß√µes pr√°ticas, √© fundamental compreender os conceitos te√≥ricos por tr√°s das optimiza√ß√µes de performance em JPA/Hibernate:

#### üîÑ **1. Lazy vs Eager Loading**
- **Lazy Loading**: Carrega dados apenas quando explicitamente acessados
  - ‚úÖ **Vantagem**: Economia de mem√≥ria e redu√ß√£o de queries desnecess√°rias
  - ‚ö†Ô∏è **Cuidado**: Pode causar LazyInitializationException fora do contexto transacional
  - üéØ **Uso**: Padr√£o recomendado para relacionamentos (`@ManyToOne`, `@OneToMany`)

- **Eager Loading**: Carrega dados imediatamente junto com a entidade principal
  - ‚ùå **Desvantagem**: Pode carregar dados desnecess√°rios
  - ‚úÖ **Vantagem**: Evita queries adicionais se os dados forem sempre necess√°rios
  - üéØ **Uso**: Apenas quando se tem certeza de que os dados ser√£o sempre usados

#### üîó **2. O Problema N+1**
**O que √©**: Execu√ß√£o de 1 query principal + N queries adicionais (uma para cada resultado)

**Exemplo pr√°tico**:
```sql
-- Query principal: buscar 100 users
SELECT * FROM users LIMIT 100;

-- N queries adicionais: uma para cada user
SELECT * FROM departments WHERE id = 1;
SELECT * FROM departments WHERE id = 2;
-- ... 98 queries a mais
```

**Impacto**: 101 queries em vez de 1 query optimizada

**Solu√ß√µes**:
- **EntityGraph**: Define quais relacionamentos carregar na query principal
- **JOIN FETCH**: For√ßa JOIN expl√≠cito na consulta JPQL
- **DTO Projections**: Carrega apenas campos necess√°rios numa √∫nica query

#### üíæ **3. Gest√£o de BLOBs (Binary Large Objects)**
**O que s√£o**: Dados bin√°rios pesados (imagens, PDFs, v√≠deos) armazenados na BD

**Problemas comuns**:
- Carregamento desnecess√°rio causa OutOfMemoryError
- Transfer√™ncia de dados massiva pela rede
- Consultas lentas devido ao tamanho dos dados

**Estrat√©gias de optimiza√ß√£o**:
- **Lazy Loading obrigat√≥rio**: `@Basic(fetch = FetchType.LAZY)`
- **Proje√ß√µes sem BLOBs**: Consultas que excluem campos BLOB
- **Endpoints separados**: Listar vs. Download
- **Streaming**: Transferir BLOBs em chunks

#### üìÑ **4. Pagina√ß√£o Eficiente**
**Por que necess√°ria**: Evita carregar milhares de registos na mem√≥ria

**Componentes**:
- **Page**: Dados da p√°gina actual
- **Pageable**: Configura√ß√£o (tamanho, n√∫mero, ordena√ß√£o)
- **Sort**: Crit√©rios de ordena√ß√£o
- **Metadata**: Total de elementos, p√°ginas, etc.

**Implementa√ß√£o correcta**:
```java
Page<User> findAll(Pageable pageable);  // ‚úÖ Correcto
List<User> findAll();                   // ‚ùå Perigoso com grandes volumes
```

#### üéØ **5. EntityGraphs**
**Finalidade**: Controlo fino sobre quais relacionamentos carregar

**Tipos**:
- **FETCH**: Carrega apenas os relacionamentos especificados
- **LOAD**: Carrega os especificados + relacionamentos EAGER da entidade

**Defini√ß√£o**:
```java
@NamedEntityGraph(
    name = "User.withDepartment",
    attributeNodes = @NamedAttributeNode("department")
)
```

**Uso**:
```java
@EntityGraph("User.withDepartment")
Optional<User> findByIdWithDepartment(Long id);
```

#### üîç **6. √çndices de Base de Dados**
**Finalidade**: Acelerar consultas atrav√©s de estruturas de dados optimizadas

**Quando criar**:
- Colunas frequentemente pesquisadas (`WHERE`, `ORDER BY`)
- Foreign keys para JOINs eficientes
- Campos √∫nicos (email, c√≥digos)

**Implementa√ß√£o JPA**:
```java
@Table(indexes = {
    @Index(name = "idx_user_email", columnList = "email"),
    @Index(name = "idx_user_department", columnList = "department_id")
})
```

### üéØ **Modelo de Dados Educativo**

Este projeto utiliza um **dom√≠nio de e-commerce** familiar para demonstrar os conceitos:

```
üë• User (Utilizador)
‚îú‚îÄ‚îÄ üè¢ Department (Departamento) - @ManyToOne
‚îî‚îÄ‚îÄ üì¶ Orders (Pedidos) - @OneToMany

üì¶ Order (Pedido)
‚îú‚îÄ‚îÄ üë§ User (Utilizador) - @ManyToOne  
‚îú‚îÄ‚îÄ üìÑ invoicePdf (PDF) - @Lob BLOB
‚îî‚îÄ‚îÄ üõí OrderItems (Itens) - @OneToMany

üõí OrderItem (Item do Pedido)
‚îú‚îÄ‚îÄ üì¶ Order (Pedido) - @ManyToOne
‚îî‚îÄ‚îÄ üéÅ Product (Produto) - @ManyToOne

üéÅ Product (Produto)
‚îú‚îÄ‚îÄ üìÅ Category (Categoria) - @ManyToOne
‚îî‚îÄ‚îÄ üñºÔ∏è imageData (Imagem) - @Lob BLOB
```

**Por que este modelo √© ideal para aprendizado**:
- **Relacionamentos comuns**: @ManyToOne, @OneToMany
- **BLOBs realistas**: PDFs de facturas, imagens de produtos
- **Cen√°rios frequentes**: Listagens, pagina√ß√£o, filtros
- **Volumes realistas**: 10K+ utilizadores, 100K+ pedidos

### üéì **Progress√£o de Aprendizado**

#### **N√≠vel 1 - Conceitos Base**
1. Compreender Lazy vs Eager
2. Identificar o problema N+1
3. Aplicar EntityGraphs b√°sicos

#### **N√≠vel 2 - Optimiza√ß√µes**
1. Implementar pagina√ß√£o eficiente
2. Usar proje√ß√µes DTO
3. Gerir BLOBs adequadamente

#### **N√≠vel 3 - Performance Avan√ßada**
1. Combinar m√∫ltiplas optimiza√ß√µes
2. Medir e monitorizar performance
3. Diagn√≥stico de problemas reais

## üéØ Objetivo

Criar um ambiente pr√°tico para demonstrar:
- ‚úÖ **Boas pr√°ticas** de JPA/Hibernate
- ‚ùå **M√°s pr√°ticas** que causam problemas de performance
- üìä **Medi√ß√£o de performance** em tempo real
- üîç **An√°lise de queries** SQL geradas
- üíæ **Gest√£o eficiente de blobs** (PDFs)
- üîÑ **Diferentes tipos de fetch** (LAZY vs EAGER)
- üìñ **Transa√ß√µes read-only** para otimiza√ß√£o

## üèóÔ∏è Estrutura do Projeto

### Entidades JPA
```
src/main/java/com/formation/hibernate/entity/
‚îú‚îÄ‚îÄ User.java          # Usu√°rios com departamento
‚îú‚îÄ‚îÄ Department.java    # Departamentos
‚îú‚îÄ‚îÄ Order.java         # Pedidos com PDF (blob)
‚îú‚îÄ‚îÄ OrderItem.java     # Itens do pedido
‚îú‚îÄ‚îÄ Product.java       # Produtos com imagem (blob)
‚îî‚îÄ‚îÄ Category.java      # Categorias de produtos
```

### DTOs e Converters
```
src/main/java/com/formation/hibernate/dto/
‚îî‚îÄ‚îÄ [V√°rios DTOs otimizados para diferentes cen√°rios]

src/main/java/com/formation/hibernate/converter/
‚îî‚îÄ‚îÄ [Converters eficientes entre entidades e DTOs]
```

### Controladores Comparativos
```
src/main/java/com/formation/hibernate/controller/
‚îú‚îÄ‚îÄ good/              # ‚úÖ Implementa√ß√µes BOAS
‚îÇ   ‚îú‚îÄ‚îÄ UserGoodController.java
‚îÇ   ‚îî‚îÄ‚îÄ OrderGoodController.java
‚îî‚îÄ‚îÄ bad/               # ‚ùå Implementa√ß√µes RUINS
    ‚îú‚îÄ‚îÄ UserBadController.java
    ‚îî‚îÄ‚îÄ OrderBadController.java
```

## üöÄ Como Executar

### 1. Executar a Aplica√ß√£o
```bash
mvn spring-boot:run
```

### 2. Popular a Base de Dados
```bash
curl -X POST http://localhost:8080/api/data/populate
```
Isto cria:
- 10 departamentos
- 10 categorias
- **10.000 usu√°rios**
- **5.000 produtos** (com imagens blob)
- **100.000 pedidos** (com PDFs blob)

### 3. Verificar Estat√≠sticas
```bash
curl http://localhost:8080/api/data/statistics
```

## üîç Demonstra√ß√µes de Performance

### Alternativa: Compara√ß√£o por Requests HTTP

Em vez de executar os containers Docker, pode comparar diretamente as pr√°ticas fazendo requests HTTP para os endpoints `good` vs `bad`:

#### üöÄ Teste R√°pido de Performance
```bash
# Primeiro, certifique-se de que a aplica√ß√£o est√° a correr
mvn spring-boot:run

# Populate dados de teste
curl -X POST http://localhost:8080/api/data/populate

# 1. Comparar busca de usu√°rio por ID
echo "=== GOOD PRACTICE - Busca por ID ===" 
time curl -s "http://localhost:8080/api/good/users/1" > /dev/null

echo "=== BAD PRACTICE - Busca por ID ===" 
time curl -s "http://localhost:8080/api/bad/users/1" > /dev/null

# 2. Comparar pagina√ß√£o de usu√°rios
echo "=== GOOD PRACTICE - Pagina√ß√£o ===" 
time curl -s "http://localhost:8080/api/good/users?page=0&size=20" > /dev/null

echo "=== BAD PRACTICE - Todos os usu√°rios ===" 
# CUIDADO: Este endpoint pode ser muito lento!
time curl -s "http://localhost:8080/api/bad/users" > /dev/null

# 3. Comparar busca por departamento
echo "=== GOOD PRACTICE - Por Departamento ===" 
time curl -s "http://localhost:8080/api/good/users/department/Tecnologia" > /dev/null

echo "=== BAD PRACTICE - Por Departamento ===" 
time curl -s "http://localhost:8080/api/bad/users/department/Tecnologia" > /dev/null

# 4. Ver resumo de performance
curl "http://localhost:8080/api/good/users/performance/summary"
curl "http://localhost:8080/api/bad/users/performance/summary"
```

#### üìä Script de Benchmark Simples
Crie um ficheiro `benchmark.sh`:
```bash
#!/bin/bash

echo "üöÄ Iniciando teste de performance..."

# Fun√ß√£o para medir tempo de resposta
measure_endpoint() {
    local name=$1
    local url=$2
    echo "Testing: $name"
    
    # Fazer 5 requests e calcular m√©dia
    total_time=0
    for i in {1..5}; do
        response_time=$(curl -o /dev/null -s -w '%{time_total}' "$url")
        total_time=$(echo "$total_time + $response_time" | bc)
        echo "  Request $i: ${response_time}s"
    done
    
    avg_time=$(echo "scale=3; $total_time / 5" | bc)
    echo "  ‚è±Ô∏è  Tempo m√©dio: ${avg_time}s"
    echo ""
}

# Compara√ß√µes
measure_endpoint "GOOD - Buscar usu√°rio" "http://localhost:8080/api/good/users/1"
measure_endpoint "BAD - Buscar usu√°rio" "http://localhost:8080/api/bad/users/1"

measure_endpoint "GOOD - Pagina√ß√£o" "http://localhost:8080/api/good/users?page=0&size=20"
measure_endpoint "BAD - Listar todos" "http://localhost:8080/api/bad/users"

echo "‚úÖ Teste conclu√≠do!"
```

Execute: `chmod +x benchmark.sh && ./benchmark.sh`

### Console H2 Database
Acesse: http://localhost:8080/h2-console
- **URL:** `jdbc:h2:mem:testdb`
- **User:** `sa`
- **Password:** `password`

### Compara√ß√£o de Endpoints

#### ‚úÖ **BOAS PR√ÅTICAS** - Endpoints `/api/good/`

**Usu√°rios:**
```bash
# Busca otimizada por ID (EntityGraph)
curl "http://localhost:8080/api/good/users/1"

# Pagina√ß√£o eficiente
curl "http://localhost:8080/api/good/users?page=0&size=20"

# Proje√ß√£o JPQL (apenas dados necess√°rios)
curl "http://localhost:8080/api/good/users/summaries"

# JOIN FETCH otimizado
curl "http://localhost:8080/api/good/users/department/Tecnologia"
```

**Pedidos:**
```bash
# EntityGraph para m√∫ltiplas rela√ß√µes
curl "http://localhost:8080/api/good/orders/1"

# Pagina√ß√£o por status
curl "http://localhost:8080/api/good/orders?status=PENDING&page=0&size=10"

# Consulta sem carregar blobs
curl "http://localhost:8080/api/good/orders/high-value?minAmount=1000"
```

#### ‚ùå **M√ÅS PR√ÅTICAS** - Endpoints `/api/bad/`

**Usu√°rios:**
```bash
# N+1 Problem garantido
curl "http://localhost:8080/api/bad/users/1"

# PERIGO: Carrega TODOS os usu√°rios
curl "http://localhost:8080/api/bad/users"

# Filtragem em mem√≥ria (p√©ssimo!)
curl "http://localhost:8080/api/bad/users/department/Tecnologia"
```

**Pedidos:**
```bash
# Carrega blobs desnecessariamente
curl "http://localhost:8080/api/bad/orders/1"

# MUITO PERIGOSO: Todos os pedidos + PDFs
curl "http://localhost:8080/api/bad/orders"
```

## üìä Medi√ß√£o de Performance

O projeto inclui um sistema de monitoriza√ß√£o que:
- ‚è±Ô∏è **Mede tempo** de execu√ß√£o de cada opera√ß√£o
- üìù **Loga detalhes** com emojis para f√°cil identifica√ß√£o
- üìà **Gera relat√≥rios** comparativos
- üéØ **Identifica gargalos** automaticamente

### Ver Resumo de Performance
```bash
curl "http://localhost:8080/api/good/users/performance/summary"
curl "http://localhost:8080/api/bad/users/performance/summary"
```

## üéì Pontos de Forma√ß√£o

### 1. **FetchType.LAZY vs EAGER**
```java
// ‚úÖ BOM: LAZY por defeito
@ManyToOne(fetch = FetchType.LAZY)
private Department department;

// ‚ùå M√ÅU: EAGER causa carregamento desnecess√°rio
// @ManyToOne(fetch = FetchType.EAGER)
// private Department department;
```

### 2. **EntityGraph vs N+1 Problem**
```java
// ‚úÖ BOM: EntityGraph resolve N+1
@EntityGraph(value = "User.withDepartment")
Optional<User> findByIdWithDepartment(Long id);

// ‚ùå M√ÅU: findById causa N+1
Optional<User> findById(Long id);
```

### 3. **Proje√ß√µes JPQL vs Entidades Completas**
```java
// ‚úÖ BOM: Apenas dados necess√°rios
@Query("SELECT new UserSummaryDto(u.id, u.name, u.email) FROM User u")
List<UserSummaryDto> findAllUserSummaries();

// ‚ùå M√ÅU: Carrega tudo
List<User> findAll();
```

### 4. **Gest√£o de Blobs**
```java
// ‚úÖ BOM: LAZY para blobs
@Lob
@Basic(fetch = FetchType.LAZY)
private byte[] invoicePdf;

// ‚ùå M√ÅU: Carrega blob sempre
// @Lob
// private byte[] invoicePdf;
```

### 5. **Transa√ß√µes Read-Only**
```java
// ‚úÖ BOM: Read-only para consultas
@Transactional(readOnly = true)
public List<User> findUsers() { ... }

// ‚ùå M√ÅU: Transa√ß√£o write desnecess√°ria
public List<User> findUsers() { ... }
```

### 6. **√çndices e Consultas**
```java
// ‚úÖ BOM: √çndices nas colunas pesquisadas
@Index(name = "idx_user_email", columnList = "email")

// ‚úÖ BOM: WHERE com √≠ndices
@Query("SELECT u FROM User u WHERE u.email = :email")

// ‚ùå M√ÅU: Sem √≠ndices, filtro em mem√≥ria
```

### 7. **Pagina√ß√£o**
```java
// ‚úÖ BOM: Pagina√ß√£o sempre
Page<User> findAll(Pageable pageable);

// ‚ùå M√ÅU: findAll() sem limite
List<User> findAll();
```

## üîß Profiles de Configura√ß√£o

### Profile `good-performance`
```bash
mvn spring-boot:run -Dspring.profiles.active=good-performance
```
- Batch size otimizado (50)
- Cache de 2¬∫ n√≠vel ativo
- Logs reduzidos

### Profile `bad-performance`
```bash
mvn spring-boot:run -Dspring.profiles.active=bad-performance
```
- Batch size p√©ssimo (1)
- Sem cache
- Logs detalhados para an√°lise

## üìà M√©tricas Esperadas

Com 100.000 registros:

| Opera√ß√£o | Boa Pr√°tica | M√° Pr√°tica | Diferen√ßa |
|----------|-------------|------------|-----------|
| Buscar 1 usu√°rio | ~5ms | ~50ms+ | **10x mais lento** |
| Listar 20 usu√°rios | ~20ms | ~2000ms+ | **100x mais lento** |
| Buscar por departamento | ~15ms | ~5000ms+ | **300x mais lento** |
| Estat√≠sticas | ~10ms | ~10000ms+ | **1000x mais lento** |

## ‚ö†Ô∏è Cuidados Importantes

1. **N√ÉO execute** `/api/bad/users` com muitos dados - pode causar OutOfMemoryError
2. **N√ÉO execute** `/api/bad/orders` - carrega TODOS os PDFs na mem√≥ria
3. Use os endpoints ruins apenas para **demonstra√ß√£o** em ambiente controlado
4. Sempre compare logs de performance entre good/bad

## üéØ Exerc√≠cios Sugeridos

1. Execute endpoints `good` e `bad` comparando logs
2. Ative profile `bad-performance` e observe diferen√ßas
3. Use H2 Console para ver queries SQL geradas
4. Me√ßa diferen√ßas de tempo de execu√ß√£o
5. Analise uso de mem√≥ria com/sem blobs
6. Teste com diferentes tamanhos de p√°gina

## üîÑ Limpar Dados

```bash
curl -X DELETE http://localhost:8080/api/data/clear
```

---

---

## üéì Branches Educacionais

Este reposit√≥rio cont√©m v√°rios branches especializados para ensino focado de conceitos espec√≠ficos:

### üìö **Main Branch**
- **Branch**: `main`
- **Conte√∫do**: Implementa√ß√£o completa com BOAS pr√°ticas
- **Uso**: Refer√™ncia de como fazer correctamente
- **Caracter√≠sticas**: 
  - EntityGraphs optimizados
  - Pagina√ß√£o em todos os endpoints
  - Gest√£o eficiente de BLOBs
  - Transac√ß√µes read-only
  - Coment√°rios educacionais em portugu√™s

### üö® **BadMain Branch**
- **Branch**: `badmain`
- **Conte√∫do**: Implementa√ß√£o completa com M√ÅS pr√°ticas intencionais
- **Uso**: Demonstra√ß√£o do que N√ÉO fazer
- **‚ö†Ô∏è AVISO**: Apenas para fins educacionais!
- **Caracter√≠sticas**:
  - Problema N+1 sistem√°tico
  - Aus√™ncia total de pagina√ß√£o
  - Carregamento desnecess√°rio de BLOBs
  - Filtragem em mem√≥ria
  - Falta de valida√ß√£o

### üéØ **Branches Focados em Conceitos Espec√≠ficos**

#### üìñ **001-n1problem** - Problema N+1
- **Foco**: Demonstra√ß√£o isolada do problema N+1
- **Cont√©m**: 
  - `N1ProblemController` com exemplos simples
  - `README-N1PROBLEM.md` com explica√ß√£o detalhada
  - Compara√ß√£o directa: bad vs EntityGraph vs JOIN FETCH
- **Aprenda**: Como detectar, medir e resolver o problema N+1

#### üìÑ **002-pagination** - Pagina√ß√£o Eficiente
- **Foco**: T√©cnicas de pagina√ß√£o para grandes volumes
- **Cont√©m**:
  - `PaginationController` com exemplos pr√°ticos
  - `README-PAGINATION.md` com guia completo
  - Demonstra√ß√£o de filtros, ordena√ß√£o e metadata
- **Aprenda**: Como evitar OutOfMemoryError com pagina√ß√£o inteligente

#### üíæ **003-blob-management** - Gest√£o de BLOBs
- **Foco**: Gest√£o eficiente de ficheiros e dados pesados
- **Cont√©m**:
  - `BlobManagementController` com cen√°rios reais
  - `README-BLOB-MANAGEMENT.md` com estrat√©gias
  - Projec√ß√µes que evitam BLOBs, streaming, metadata
- **Aprenda**: Como trabalhar com BLOBs sem quebrar a performance

### üöÄ **Como Usar os Branches Educacionais**

#### 1. **Aprendizado Progressivo**
```bash
# Come√ßar com conceitos b√°sicos
git checkout 001-n1problem
# Ler README-N1PROBLEM.md
# Testar endpoints /api/n1-demo/*

# Avan√ßar para pagina√ß√£o
git checkout 002-pagination
# Ler README-PAGINATION.md
# Testar endpoints /api/pagination-demo/*

# Dominar gest√£o de BLOBs
git checkout 003-blob-management
# Ler README-BLOB-MANAGEMENT.md
# Testar endpoints /api/blob-demo/*
```

#### 2. **Compara√ß√£o de Implementa√ß√µes**
```bash
# Ver implementa√ß√£o m√°
git checkout badmain
curl "http://localhost:8080/api/users" # LENTO!

# Ver implementa√ß√£o boa
git checkout main
curl "http://localhost:8080/api/good/users?page=0&size=20" # R√ÅPIDO!
```

#### 3. **Exerc√≠cios Pr√°ticos**
```bash
# Branch focado para praticar N+1
git checkout 001-n1problem
mvn spring-boot:run
curl "http://localhost:8080/api/n1-demo/bad/1"     # Ver problema
curl "http://localhost:8080/api/n1-demo/good-entitygraph/1"  # Ver solu√ß√£o
```

### üìä **Compara√ß√£o entre Branches**

| Branch | Prop√≥sito | N+1 Problem | Pagina√ß√£o | BLOBs | Complexidade |
|--------|-----------|-------------|-----------|-------|--------------|
| `main` | ‚úÖ Refer√™ncia boa | ‚úÖ Resolvido | ‚úÖ Sempre | ‚úÖ Optimizado | üü° Complexa |
| `badmain` | ‚ùå Anti-padr√µes | ‚ùå Sistem√°tico | ‚ùå Nunca | ‚ùå Perigoso | üü° Complexa |
| `001-n1problem` | üéì Foco N+1 | üéØ **FOCO** | ‚ûñ M√≠nimo | ‚ûñ M√≠nimo | üü¢ Simples |
| `002-pagination` | üéì Foco Pagina√ß√£o | ‚ûñ M√≠nimo | üéØ **FOCO** | ‚ûñ M√≠nimo | üü¢ Simples |
| `003-blob-management` | üéì Foco BLOBs | ‚ûñ M√≠nimo | ‚ûñ M√≠nimo | üéØ **FOCO** | üü¢ Simples |

### üéØ **Plano de Estudos Sugerido**

#### üìö **N√≠vel Iniciante**
1. Ler `README-N1PROBLEM.md` no branch `001-n1problem`
2. Executar compara√ß√µes simples de N+1
3. Compreender EntityGraphs b√°sicos

#### üìà **N√≠vel Interm√©dio**
1. Dominar pagina√ß√£o no branch `002-pagination`
2. Praticar consultas optimizadas
3. Aprender gest√£o de BLOBs no branch `003-blob-management`

#### üèÜ **N√≠vel Avan√ßado**
1. Comparar `main` vs `badmain` integralmente
2. Medir performance real com ferramentas
3. Implementar optimiza√ß√µes pr√≥prias

---

**üìö Este projeto √© uma ferramenta educativa completa para compreender profundamente as implica√ß√µes de performance em JPA/Hibernate atrav√©s de exemplos pr√°ticos, medi√ß√µes reais e aprendizado progressivo por conceitos espec√≠ficos.**